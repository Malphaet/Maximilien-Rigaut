

{{{id=1|
# --------------------- #
# Fonctions Utilitaires #
# --------------------- #

def ExpoRapide(x,p,n):
    if p==0: return 1
    if p%2==0:
        temp=ExpoRapide(x,p/2,n)%n
        return temp*temp%n
    else:
        temp=ExpoRapide(x,(p-1)/2,n)%n
        return x*temp*temp%n

def div(d,b):
    s = 0
    while d%b==0: s,d=s+1,d/b
    return (s,d)
///
}}}

{{{id=27|
# ------------ #
# Classes Clef #
# ------------ #

class Clef_pub(object):
    def __init__(self,e,n):
        self.clef=e
        self.modulo=n
        self.__dict__={'clef':self.clef,'modulo':self.modulo}
    def __str__(self):
        return str((self.clef,self.modulo))
    def listall(self):
        for cle in self.__dict__: print cle,self.__dict__[cle]
class Clef_priv(Clef_pub):
    def __init__(self,e,d,n,p,q):
        Clef_pub.__init__(self,d,n)
        self.clef_p=d%(p-1)
        self.clef_q=d%(q-1)
        self.q_inv=Inverse(q,p)
        self.p,self.q=p,q
        self.__dict__.update({'clef_p':self.clef_p,'clef_q':self.clef_q})
///
}}}

{{{id=2|
# --------------------- #
# Fonctions Importantes #
# --------------------- #

def MillerRabin(n):
    test=[2,3,5,7,13,17,31,71]
    if n<4: return True
    if n%2==0: return False
    d,s=n-1,0
    while d%2==0: s,d=s+1,d/2
    if log(d)<100: test=test[:4]
    def EssaiCompose(a):
        x=ExpoRapide(a,d,n)
        if x==1: return False
        for i in range(s):
            x=x*x%n
            if x==n-1: return False 
        return True # Composé
    for a in test: 
        if EssaiCompose(a): return False
    return True

def Prim(i):
    j=4
    while not MillerRabin(j):
        j=0
        for ex in range(i):
            j+=randint(0,9)*(10**ex)
        while not MillerRabin(j):
            j+=randint(1,10)
            if j.digits()>i: break
    return j

def PremierAvec(a,n):
    assert(a>2)
    while True:
        i=randint(2,n)
        b,j = a,i
        if b<j: b,j=j,b
        while j>0: b,j=j,b%j
        if b==1: return i

def EuclideEtendu(a, n):
    if n == 0: return (1, 0)
    q = a//n
    r = a - n*q
    s,t = EuclideEtendu(n,r)
    return (t, s - q * t)

def Inverse(a,n): 
    res=EuclideEtendu(a,n)[0]
    if res<0: return res+n
    return res

def CleInit(i):
    "Génère deux clef de taille > <2i> chacune renvoie <pub>,<priv>"
    p,q=Prim(i),Prim(i)
    n,mx=p*q,(p-1)*(q-1)
    e=PremierAvec(mx,mx)
    d=Inverse(e,mx)
    c1,c2=Clef_pub(e,n),Clef_priv(e,d,n,p,q)     # Old fashion: ((d,n),(e,n))
    return c1,c2

def Chiffrement(m,c): 
    #return ExpoRapide(m,c[0],c[1])
    if m>c.modulo:
        n,l,temp=str(m),len(str(c.modulo)),''
        lm=len(n)
        for i in range(int(lm//l)):
            x=Chiffrement(m[i*l,i*(l+1)],c)
            print x,len(x)
            temp=temp+x
        return int(temp)
    return m.powermod(c.clef,c.modulo)

def Dechiffrement(m,c1,c2):
    #return Chiffrement(m,c2)
    m1=m.powermod(c2.clef_p,c2.p)
    m2=m.powermod(c2.clef_q,c2.q)
    ad=m1-m2
    if ad<0:ad+=c2.p
    h = (c2.q_inv * (ad)) % c2.p
    return m2+h*c2.q

def Encodage(s,size):
    mx=len(s)
    msg,i=10**(3*mx),0
    for char in s:
        msg+=ord(char)*10**(3*(mx-i-1))
        i+=1
    table=[msg[i*size,i*(size+1)] for i in range(len(msg)/size)]
    print table 
    return msg

def Decodage(m,c):
    msg,m='',str(m)
    i,mx=0,(len(m)-1)/3
    while i<mx:
        msg=msg+chr(int(m[i*3+1:(i+1)*3+1]))
        i+=1
    return msg

def RSA(s,i):
    c1,c2= CleInit(i)
    size=len(str(c1.modulo))
    print 'Clef 1',c1
    print 'Clef 2',c2
    m=Encodage(s,size)
    m_enc=Chiffrement(m,c1)
    print 'Message Encodé:',m
    print 'Message Encripté:',m_enc
    m_dec=Dechiffrement(m_enc,c1,c2)
    m=Decodage(m_dec,size)
    print 'Message Decripté:',m_dec
    print 'Message Decodé:',m
///
}}}

{{{id=11|
# -------------------- #
# Programme Principal  #
# -------------------- #

#print Prim(42)
#print PremierAvec(20.factorial(),20.factorial())
#print Inverse(44,7)

#c1,c2,m= CleInit(42),42
#m_enc=Chiffrement(m,c1)
#m_dec=Dechiffrement(m_enc,c1,c2)
#print m,m_enc,m_dec

RSA("Mon Nom Est Quelqu'un",12)
///
Clef 1 (36894273598311447964507L, 101126366303709662980957)
Clef 2 (87263689646558928950483, 101126366303709662980957)
Traceback (most recent call last):    #print Inverse(44,7)
  File "", line 1, in <module>
    
  File "/private/var/folders/Tk/Tks3RfQREqGxd1aWcYcvwU+++TI/-Tmp-/tmpP9UomH/___code___.py", line 15, in <module>
    exec compile(u'RSA("Mon Nom Est Quelqu\'un",_sage_const_12 )' + '\n', '', 'single')
  File "", line 1, in <module>
    
  File "/private/var/folders/Tk/Tks3RfQREqGxd1aWcYcvwU+++TI/-Tmp-/tmp6IR9Ve/___code___.py", line 109, in RSA
    m=Encodage(s,size)
  File "/private/var/folders/Tk/Tks3RfQREqGxd1aWcYcvwU+++TI/-Tmp-/tmp6IR9Ve/___code___.py", line 92, in Encodage
    table=[msg[i*size,i*(size+_sage_const_1 )] for i in range(len(msg)/size)]
TypeError: object of type 'sage.rings.integer.Integer' has no len()
}}}

{{{id=18|
# -------------- #
# Fonctions Test #
# -------------- #

def test_prime_function(f):
    dic={643808006803554439230129854961492699151386107534013432918073439524138264842370630061369715394739134090922937332590384720397133335969549256322620979036686633213903952966175107096769180017646161851573147596390153: False,
1000000000000066600000000000001:True,
    270568443558689485333633588052890364054007893892773601191557514831184795421181950854385181053591716234181701274608324778811433964142183708836456011872051376743012138953416240415328311:True,
    13:True,
    7859845794865794857984567984:False,
    55644787:False,
743808006803554439230129854961492699151386107534013432918073439524138264842370630061369715394739134090922937332590384720397133335969549256322620979036686633213903952966175107096769180017646161851573147596390153: False}
    errors=[]
    for i in dic:
        if not f(i)==dic[i]: errors.append([f(i),"f(%i)=%s != %s"%(i,f(i),dic[i])])
    return errors
    

for i in test_prime_function(MillerRabin): print i[0]
///
False
}}}

{{{id=26|

///
}}}

{{{id=28|

///
}}}

{{{id=29|

///
}}}